c("IntraGameProprioception","TissueWeakness","NeuromuscularFatigue","FitnessLevel","Genetics"),
c("IntraGameProprioception","TissueWeakness","NeuromuscularFatigue","FitnessLevel","Coach"),
c("IntraGameProprioception","TissueWeakness","FitnessLevel","TeamMotivation","NeuromuscularFatigue"),
c("IntraGameProprioception","TissueWeakness","NeuromuscularFatigue","Coach","PreGameProprioception"),
c("IntraGameProprioception","TissueWeakness","TeamMotivation","NeuromuscularFatigue","PreGameProprioception"),
c("IntraGameProprioception","TissueWeakness","WarmUpExercises","NeuromuscularFatigue"),
c("NeuromuscularFatigue","PreGameProprioception","FitnessLevel"),
c("NeuromuscularFatigue","PreviousInjury","TeamMotivation"),
c("NeuromuscularFatigue","PreviousInjury","Coach"),
c("NeuromuscularFatigue","PreviousInjury","Genetics","FitnessLevel"),
c("NeuromuscularFatigue","TeamMotivation","Coach"),
c("NeuromuscularFatigue","TeamMotivation","Genetics","FitnessLevel"),
c("NeuromuscularFatigue","WarmUpExercises","PreGameProprioception","TeamMotivation"),
c("NeuromuscularFatigue","WarmUpExercises","PreGameProprioception","Coach"),
c("NeuromuscularFatigue","WarmUpExercises","TeamMotivation","FitnessLevel"),
c("NeuromuscularFatigue","WarmUpExercises","Coach","FitnessLevel"),
c("NeuromuscularFatigue","WarmUpExercises","Genetics","FitnessLevel"),
c("PreGameProprioception","PreviousInjury","TeamMotivation"),
c("PreGameProprioception","PreviousInjury","Coach"),
c("PreGameProprioception","PreviousInjury","FitnessLevel"),
c("PreGameProprioception","TeamMotivation","Coach"),
c("PreGameProprioception","TeamMotivation","FitnessLevel"),
c("PreGameProprioception","TissueWeakness","ConnectiveTissueDisorder","NeuromuscularFatigue"),
c("PreGameProprioception","TissueWeakness","FitnessLevel"),
c("PreviousInjury","TissueWeakness","ConnectiveTissueDisorder","NeuromuscularFatigue"),
c("PreviousInjury","TissueWeakness","FitnessLevel","Genetics"),
c("PreviousInjury","TissueWeakness","Coach"),
c("PreviousInjury","TissueWeakness","TeamMotivation"),
c("PreviousInjury","WarmUpExercises","TeamMotivation"),
c("TeamMotivation","TissueWeakness","ConnectiveTissueDisorder","NeuromuscularFatigue"),
c("TeamMotivation","TissueWeakness","FitnessLevel","Genetics"),
c("TeamMotivation","TissueWeakness","Coach"),
c("TissueWeakness","WarmUpExercises","PreGameProprioception","TeamMotivation"),
c("TissueWeakness","WarmUpExercises","PreGameProprioception","Coach"),
c("TissueWeakness","WarmUpExercises","TeamMotivation","FitnessLevel"),
c("TissueWeakness","WarmUpExercises","Coach","FitnessLevel"),
c("TissueWeakness","WarmUpExercises","Genetics","FitnessLevel"),
c("TissueWeakness","WarmUpExercises","NeuromuscularFatigue","ConnectiveTissueDisorder"))
data.frame( implication=unlist(lapply(implications,tos)),
pvalue=unlist( lapply( implications, tst ) ) )
}
View(testImplications)
View(testImplications)
View(testImplications)
?gwr.basic
knitr::opts_chunk$set(echo = TRUE)
easypackages::packages ("sf", "sp", "spdep", "spatialreg", "GWmodel", "tmap", "mapview", "car", "RColorBrewer",
"cowplot", "leafsync", "leaflet.extras2", "mapview", "tidyverse", "DT")
?gwr.basic
library(tidyverse)
df <- read_csv("funda_buy_17-03-2023.csv")
df <- read_csv("funda_buy_17-03-2023.csv")
model <- lm(data = df, price~room +living_area + house_age + house_type)
summary(model)
library(tidygeocoder)
df_new <- df %>%
top_n(10) %>%
mutate(adddreszip = paste0(address, ", Noord-Holland")) %>%
geocode(adddreszip, method = 'osm', lat = latitude , long = longitude)
View(df_new)
library(tidygeocoder)
df_new <- df %>%
top_n(10) %>%
mutate(adddreszip = paste0(address, ", Noord-Holland")) %>%
geocode(adddreszip, method = 'mapbox', lat = latitude , long = longitude)
Sys.setenv(MAPBOX_API_KEY = "pk.eyJ1IjoidGhvbWFzbmliIiwiYSI6ImNsZmkzYmNpNzBmNzQzeHFwa212MTE1bWsifQ.vx281RPGcBNgqDrUMsHfhw")
library(tidygeocoder)
df_new <- df %>%
top_n(10) %>%
mutate(adddreszip = paste0(address, ", Noord-Holland")) %>%
geocode(adddreszip, method = 'mapbox', lat = latitude , long = longitude)
View(df_new)
library(leaflet)
leaflet(df_new) %>% addTiles() %>%
addCircleMarkers(lng = ~longitude, lat = ~latitude,
popup = ~address)
Sys.unsetenv(MAPBOX_API_KEY )
Sys.unsetenv(MAPBOX_API_KEY)
df_new <- df %>%
top_n(10) %>%
mutate(adddreszip = paste0(address, ", Noord-Holland")) %>%
geocode(adddreszip, method = 'mapbox', lat = latitude , long = longitude)
Sys.setenv(MAPBOX_API_KEY = "pk.eyJ1IjoidGhvbWFzbmliIiwiYSI6ImNsZmkzYmNpNzBmNzQzeHFwa212MTE1bWsifQ.vx281RPGcBNgqDrUMsHfhw")
Sys.unsetenv(MAPBOX_API_KEY)
Sys.getenv()
knitr::opts_chunk$set(echo = TRUE)
#clean your environment
#rm(list=ls())
#Loading the spatial data. This s GEOPACKAGE format data which is a really efficient GIS data format, compared to shape files
#use the SF package to bring the data
greendata <- st_read("C:/Users/jitse/OneDrive - Universiteit Utrecht/Spatial Statistics and Machine Learning/Session-3_Labib/GreenYPLL_Man_EXD.gpkg")
easypackages::packages ("sf", "sp", "tmap", "mapview", "car", "RColorBrewer", "tidyverse", "osmdata", "nngeo", "FNN", "rpart", "rpart.plot", "sessioninfo", "caret", "rattle", "ipred", "tidymodels", "ranger", "modelStudio", "DALEX", "DALEXtra", "vip", "pdp", "rgeos", "spatialRF")
#clean your environment
#rm(list=ls())
#Loading the spatial data. This s GEOPACKAGE format data which is a really efficient GIS data format, compared to shape files
#use the SF package to bring the data
greendata <- st_read("C:/Users/jitse/OneDrive - Universiteit Utrecht/Spatial Statistics and Machine Learning/Session-3_Labib/GreenYPLL_Man_EXD.gpkg")
citybound <- st_read ("C:/Users/jitse/OneDrive - Universiteit Utrecht/Spatial Statistics and Machine Learning/Session-3_Labib/citybound_WGS84_GM.gpkg")
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
seed = random.seed
)
bikefac <-  opq(st_bbox(citybound)) %>%
add_osm_feature(key = "amenity", c("bicycle_parking", "bicycle_repair_station", "bicycle_rental")) %>%
osmdata_sf ()
bikefac_points <- st_as_sf (bikefac$osm_points) %>% dplyr:: select(osm_id, amenity)
Dailyshops <- opq(st_bbox(citybound)) %>%
add_osm_feature(key = "shop", c("department_store", "supermarket", "convenience")) %>%
osmdata_sf ()
Dailyshops_points <- st_as_sf (Dailyshops$osm_points) %>% dplyr:: select(osm_id, shop)
tm_shape(bikefac_points) +
tm_dots (col="green") +
tm_shape(Dailyshops_points) +
tm_dots(col="dodgerblue3")
greendatacen <- st_centroid(greendata)
greendatacen <- st_centroid(greendata)
#Re-project the point layer from WGS to local projection to have unit in meter
bikefac_points <-  st_transform (bikefac_points, 27700)
#Re-project the point layer from WGS to local projection to have unit in meter
shop_points <-  st_transform (Dailyshops_points, 27700)
#now we would write our own function to estimate distance using nearest neighbor algorithm
#This function take an origin point (from), and a destination point (to), and then use nn function of FNN package to estimate the distance to the nearest (k =1) neighborhood location
nn_function <- function(measureFrom,measureTo,k) {
measureFrom_Matrix <- as.matrix(measureFrom)
measureTo_Matrix <- as.matrix(measureTo)
nn <-
get.knnx(measureTo, measureFrom, k)$nn.dist [,k]
return(nn)
}
#now we will use the nn_function to measure the shortest distance from neighborhood centroid to  bike facilities (i.e., bikefac_points)
#distance to bike facilities (shops, repair, parking)
greendatacen <- greendatacen %>%
mutate(bikefac_dist_new = nn_function(st_coordinates(greendatacen$geom), st_coordinates(bikefac_points$geom), 1))
#distance to shops
greendatacen <- greendatacen %>%
mutate(Shop_dist_new = nn_function(st_coordinates(greendatacen$geom), st_coordinates(shop_points$geom), 1))
#you can see the data frame and there is new column at the end.
#view(greendatacen)
#this is how you can convert the raw OSM data into a spatial indicator
#First define the relationship
eq_green <- Pre_mortality ~ Green_avail + SHDiv + Income_Sco + Crime_Scor + Barriers_H + PM10 + density_pp + bikefac_dist_new + ffood_dist + gpp_dist_a
eq_green
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
seed = random.seed
)
#We need an unique ID and coordinates for evaluating the spatial correlations
greendatacen$id <- 1:nrow(greendatacen) #this is to give an unique ID to each row
greendatacen$x <- st_coordinates(greendatacen)[, 1] #get the X coordinate of the point
greendatacen$y <- st_coordinates(greendatacen)[, 2] #get the Y coordinate of the point
#now convert the file into a SP object, as the gDistance function we are using from rgeos package can only work on SP object
greendatacen_sp <- as_Spatial(greendatacen)
#calculate the distance matrix based on sp object
distance_matrix <- gDistance(greendatacen_sp, byid=TRUE)
#distance thresholds (same units as distance_matrix)
distance.thresholds <- c(0, 100, 300, 500) #these thresholds indicates when we are considering spatial pattern how far we look for neighborhoods, in this case we are going up to 500 m
#drop the geometry column from the main sf object so it does not cause issues with the spatialRF functions
greendatacen_spdf <- greendatacen %>% st_drop_geometry()
#create a xy list for coordinates to plot local importance, if you want check details: https://blasbenito.github.io/spatialRF/
xy <- greendatacen_spdf[, c("x", "y")]
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
seed = random.seed
)
random.seed <- set.seed(123)
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
seed = random.seed
)
random.seed <- set.seed(123)
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
seed = random.seed
)
random.seed <- set.seed(123)
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
seed = random.seed
)
#print the model result
spatialGreeneRF
random.seed <- set.seed(123)
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
n.cores = parallel::detectCores() - 2
seed = random.seed
random.seed <- set.seed(123)
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
n.cores = parallel::detectCores() - 2,
seed = random.seed
)
random.seed <- set.seed(123)
#Spatial RF
spatialGreeneRF <- spatialRF::rf_spatial(
data = greendatacen_spdf,
dependent.variable.name = "Pre_mortality",
predictor.variable.names = c("Green_avail", "SHDiv", "Income_Sco", "Crime_Scor", "Barriers_H", "PM10", "density_pp","bikefac_dist_new", "ffood_dist", "gpp_dist_a", "NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
distance.matrix = distance_matrix,
distance.thresholds = 0, #here we selected zero as in non-spatial model we found at multiple thresholds they all show auto-correlation
method = "mem.moran.sequential", #default method, you can select other methods too such as mem.effect.recursive, check help for details
ranger.arguments = list( #this part we keep same as non-spatial model
mtry = 3,
min.node.size = 5,
num.trees = 500
),
verbose = FALSE,
n.cores = parallel::detectCores() - 2,
seed = random.seed
)
#print the model result
spatialGreeneRF
VIPrep <- spatialRF::plot_importance(
spatialGreeneRF.repeat,
verbose = FALSE
)
PDP1 <- spatialRF::plot_response_curves(
spatialGreeneRF.repeat,
variables = c("Income_Sco", "Barriers_H", "Crime_Scor", "density_pp", "Green_avail", "PM10","NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
quantiles = 0.5,
ncol = 3,
verbose = TRUE
) +
ggplot2::ggtitle("Spatial RF")
PDP1 <- spatialRF::plot_response_curves(
spatialGreeneRF,
variables = c("Income_Sco", "Barriers_H", "Crime_Scor", "density_pp", "Green_avail", "PM10","NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
quantiles = 0.5,
ncol = 3,
verbose = TRUE
) +
ggplot2::ggtitle("Spatial RF")
PDP1 <- spatialRF::plot_response_curves(
spatialGreeneRF,
variables = c("Income_Sco", "Barriers_H", "Crime_Scor", "density_pp", "Green_avail", "PM10","NightLightmean", "RNoiseLmedian", "LSTSummer17mean"),
quantiles = 0.5,
ncol = 3,
verbose = TRUE
) +
ggplot2::ggtitle("Spatial RF")
PDP1
#This part we try to tune the hyper parameters of the fitted model
#It might take some time
spatialGreeneRF <- rf_tuning(
model = spatialGreeneRF,
xy = xy, #location indicating coordinates of each neighborhood
repetitions = 5, #times the tuning process will run, such as K fold CV, here 5 means we used 5 folds
num.trees = c(100, 1000), #the range within which the number of trees the model can select
mtry = seq(
2,
length(spatialGreeneRF$ranger.arguments$predictor.variable.names), #number of predictors
by = 9),
min.node.size = c(5, 15), #minimum rows the model can pick between 5 to 15
seed = random.seed,
n.cores = 2, #used for faster calculation, check how many cores your laptop has before selecting the core numbers
verbose = FALSE
)
#This part we try to tune the hyper parameters of the fitted model
#It might take some time
spatialGreeneRF_tune <- rf_tuning(
model = spatialGreeneRF,
xy = xy, #location indicating coordinates of each neighborhood
repetitions = 5, #times the tuning process will run, such as K fold CV, here 5 means we used 5 folds
num.trees = c(100, 1000), #the range within which the number of trees the model can select
mtry = seq(
2,
length(spatialGreeneRF$ranger.arguments$predictor.variable.names), #number of predictors
by = 9),
min.node.size = c(5, 15), #minimum rows the model can pick between 5 to 15
seed = random.seed,
n.cores = 2, #used for faster calculation, check how many cores your laptop has before selecting the core numbers
verbose = FALSE
)
setwd("C:\\Users\\jitse\\Documents\\GitHub\\Amsterdam_house_prices\\data")
library(tidyverse)
df <- read_csv("funda_buy_17-03-2023.csv")
model <- lm(data = df, price~room +living_area + house_age + house_type)
summary(model)
library(tidygeocoder)
df_new <- df %>%
top_n(10) %>%
mutate(adddreszip = paste0(address, ", Noord-Holland")) %>%
geocode(adddreszip, method = 'osm', lat = latitude , long = longitude)
easypackages::packages ("sf", "sp", "spdep", "spatialreg", "GWmodel", "tmap", "mapview", "car", "RColorBrewer",
"cowplot", "leafsync", "leaflet.extras2", "mapview", "tidyverse")
library(sf)
df_sp <- df_new %>% drop_na()
x = st_as_sf(df_sp, coords = c( "longitude", "latitude"), crs = 4326)
x <- st_transform(x, crs = 28992)
st_write(x, "test.gpkg")
library(sf)
df_sp <- df_new %>% drop_na()
x = st_as_sf(df_sp, coords = c( "longitude", "latitude"), crs = 4326)
x <- st_transform(x, crs = 28992)
st_write(x, "test.gpkg")
qtm(x)
greendata_sp <- as_Spatial(x)
#fit the adaptive kernel
#find adaptive kernel using gaussian function
abw <- bw.gwr(price~room +living_area + house_age,
approach = "AIC", #specified by CV for cross-validation approach or by AIC corrected (AICc), we used AIC
adaptive = TRUE,
kernel="gaussian", #this can be different function e.g., bisquare,exponential, depend on the prior understanding or choice of the modeler
data=greendata_sp) #give the sp data created earlier
#fitting the model with gwr.basic function
a.gwr <- gwr.basic(price~room +living_area + house_age, #the equation
adaptive = TRUE,
kernel="gaussian", #indicate the Kernel again
bw = 17, #give the optimal bandwidth we found in the last stage
data=greendata_sp)
#print the model result
a.gwr
multiGWR <- gwr.multiscale(price~room +living_area + house_age,
data = greendata_sp,
adaptive = T,
max.iterations = 10, #usually large number to make sure each variable converage to best bandwidth
criterion="CVR", #criterion for determining the convergence of the back-fitting procedure
kernel = "bisquare", #kernel can also be gaussian, exponential
bws0=c(10,10,10), #starting number of neighbors
verbose = F, predictor.centered=rep(T, 6))
multiGWR
df_new <- df %>%
top_n(1000) %>%
mutate(adddreszip = paste0(address, ", Noord-Holland")) %>%
geocode(adddreszip, method = 'osm', lat = latitude , long = longitude)
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(leaflet)
df <- read.csv('data/test/funda_buy_21-03-2023(sample100p)')
knitr::opts_chunk$set(echo = TRUE)
df <- read.csv('data/test/funda_buy_21-03-2023(sample100p).csv')
leaflet(df) %>% addTiles() %>%
addCircleMarkers(lng = ~longitude, lat = ~latitude,
popup = ~address)
df <- read.csv('data/test/funda_buy_21-03-2023(sample100p).csv')
leaflet(df) %>% addTiles() %>%
addCircleMarkers(lng = ~longitude, lat = ~latitude,
popup = ~address)
View(df_new)
write.csv(df_new, 'data/test/funda_buy_21-03-2023(sample100p)latlon.csv')
leaflet(df) %>% addTiles() %>%
addCircleMarkers(lng = ~longitude, lat = ~latitude,
popup = ~address)
df <- read.csv('data/test/funda_buy_21-03-2023(sample100p)latlon.csv')
leaflet(df) %>% addTiles() %>%
addCircleMarkers(lng = ~longitude, lat = ~latitude,
popup = ~address)
View(df_new)
knitr::opts_chunk$set(echo = TRUE)
easypackages::packages ("sf", "sp", "tmap", "mapview", "car", "RColorBrewer", "tidyverse", "osmdata", "nngeo", "FNN", "rpart", "rpart.plot", "sessioninfo", "caret", "rattle", "ipred", "tidymodels", "ranger", "modelStudio", "DALEX", "DALEXtra", "vip", "pdp", "rgeos", "spatialRF")
easypackages::packages("sf", "sp", "osmdata", "FNN", "tidyverse")
easypackages::packages("sf", "sp", "osmdata", "FNN", "tidyverse")
province_boundaries <- st_read ("data/Noord_Holland.gpkg")
funda_data <- st_read ("data/funda_buy_28-03-2023_full.gpkg")
# Get OSM data
bus <-  opq(st_bbox(province_boundaries)) %>%
add_osm_feature(key = "amenity", c("bus_station")) %>%
osmdata_sf ()
easypackages::packages("tidyverse", "sf", "mapview", "RColorBrewer", "tmap", "car", "spdep", "spatialreg")
gwr_result<- st_read("data/gwr_result.gpkg")
gwr_result<- st_read("data/gwr_result_full.gpkg")
setwd("~/GitHub/Noord_Holland_house_prices")
gwr_result<- st_read("data/gwr_result_full.gpkg")
gwr_result<- st_read("data/gwr_results_full.gpkg")
gwr_result<- st_read("data/gwr_results_full.gpkg")
View(gwr_result)
gwr_result<- st_read("data/gwr_results_full.gpkg")
gwr_result<- st_read("data/gwr_results_full.gpkg")
bus <- gwr_result(gwr_result, zcol = "bus_dist", col.regions=brewer.pal(9, "YlOrRd"))
train <- gwr_result(gwr_result, zcol = "train_dist", col.regions=brewer.pal(9, "YlOrRd"))
subway <- gwr_result(gwr_result, zcol = "subway_dist", col.regions=brewer.pal(9, "YlOrRd"))
gwr_result<- st_read("data/gwr_results_full.gpkg")
bus <- gwr_result(gwr_result, zcol = "bus_dist", col.regions=brewer.pal(9, "YlOrRd"))
bus <- mapview(gwr_result, zcol = "bus_dist", col.regions=brewer.pal(9, "YlOrRd"))
train <- mapview(gwr_result, zcol = "train_dist", col.regions=brewer.pal(9, "YlOrRd"))
subway <- mapview(gwr_result, zcol = "subway_dist", col.regions=brewer.pal(9, "YlOrRd"))
sync(bus,train,subway)
sync(bus,train,subway)
easypackages::packages("tidyverse", "sf", "mapview", "RColorBrewer", "tmap", "car", "spdep", "spatialreg", "leafsync")
gwr_result<- st_read("data/gwr_results_full.gpkg")
bus <- mapview(gwr_result, zcol = "bus_dist", col.regions=brewer.pal(9, "YlOrRd"))
train <- mapview(gwr_result, zcol = "train_dist", col.regions=brewer.pal(9, "YlOrRd"))
subway <- mapview(gwr_result, zcol = "subway_dist", col.regions=brewer.pal(9, "YlOrRd"))
sync(bus,train,subway)
bus <- mapview(gwr_result, zcol = "living_area", col.regions=brewer.pal(9, "YlOrRd"))
train <- mapview(gwr_result, zcol = "train_dist", col.regions=brewer.pal(9, "YlOrRd"))
subway <- mapview(gwr_result, zcol = "subway_dist", col.regions=brewer.pal(9, "YlOrRd"))
sync(bus,train,subway)
bus
View(gwr_result)
bus <- mapview(gwr_result, zcol = "residual", col.regions=brewer.pal(9, "YlOrRd"))
train <- mapview(gwr_result, zcol = "train_dist", col.regions=brewer.pal(9, "YlOrRd"))
subway <- mapview(gwr_result, zcol = "subway_dist", col.regions=brewer.pal(9, "YlOrRd"))
bus
View(gwr_result)
bus <- mapview(gwr_result, zcol = "university_dist", col.regions=brewer.pal(9, "YlOrRd"))
bus
gwr_result %>%
ggplot(aes(x = residual)) + geom_density2d()
gwr_result %>%
ggplot(aes(x = residual)) + geom_density()
gwr_result %>%
ggplot(aes(x = residual)) + geom_histogram()
gwr_result %>%
ggplot(aes(x = residual)) + geom_density()
bus <- mapview(gwr_result, zcol = "room", col.regions=brewer.pal(9, "YlOrRd"))
map <- mapview(gwr_result, zcol = "room", col.regions=brewer.pal(9, "YlOrRd"))
map
map <- mapview(gwr_result, zcol = "living_area", col.regions=brewer.pal(9, "YlOrRd"))
map
map <- mapview(gwr_result, zcol = "living_area_TV", col.regions=brewer.pal(9, "YlOrRd"))
map
map <- mapview(gwr_result, zcol = "room", col.regions=brewer.pal(9, "YlOrRd"))
map
map <- mapview(gwr_result, zcol = "house_age", col.regions=brewer.pal(9, "YlOrRd"))
map
