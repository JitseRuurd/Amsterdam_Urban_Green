---
title: "R Notebook"
output: html_notebook
---

```{r}
library(tidyverse)
library(tidygeocoder)
library(leaflet)
library(sf)
library(tmap)
library(spatialreg)
library(GWmodel)
library(RColorBrewer)
library(mapview)
library(leafsync)
```

```{r}
df <- read_csv("Scraper/data/funda_buy_28-03-2023_full.csv")

str(df)
df <-  df %>% 
  mutate(house_type = factor(house_type),
         building_type = factor(building_type),
         energy_label = factor(energy_label),
         has_balcony = factor(has_balcony),
         has_garden = factor(has_garden))
str(df)
  
```

```{r}
model <- lm(data = df, price~ house_type + building_type + room + bedroom + bathroom + living_area + energy_label +has_balcony + has_garden + house_age)
summary(model)
```

```{r}
df_new <- df %>% 
  separate(address_line, c("zip", "letters", "city", "optional1","optional2", "optional3", "optional4"), " ") %>% 
  mutate(addressline_city = paste(city, optional1, optional2, optional3, optional4),
         addressline_zip = paste(zip, letters),
         addresszip = paste0(address, ", ",addressline_zip, ", ", city, ", Nederland")) %>% 
  select(-optional1, -optional2, -optional3, -optional4) %>% 
  geocode(addresszip, method = 'osm', lat = latitude , long = longitude)
#write.csv(df_new,"data/funda_buy_28-03-2023_full_latlon.csv")
#df_new %>% 
#  select(longitude, latitude, price, room, living_area, house_age) %>% 
#  write.csv("data/test/mgwr.csv")
```
```{r}
#write.csv(df_new,"data/funda_buy_28-03-2023_full_latlon.csv")
#df_sp <- df_new %>% drop_na()
#x = st_as_sf(df_sp, coords = c( "longitude", "latitude"), crs = 4326)
#x <- st_transform(x, crs = 28992)
#st_write(x, "data/funda_buy_28-03-2023_full.gpkg")

```



```{r}

leaflet(df_new) %>% addTiles() %>%
  addCircleMarkers(lng = ~longitude, lat = ~latitude, 
             popup = ~address)
```


```{r}

#df_sp <- df_new %>% drop_na()
#x = st_as_sf(df_sp, coords = c( "longitude", "latitude"), crs = 4326)
#x <- st_transform(x, crs = 28992)
#st_write(x, "data/test/test_sample(100p).gpkg")
#x <- st_read("data/test/test_sample(100p).gpkg")
```

```{r}

qtm(x)
```

```{r}
greendata_sp <- as_Spatial(x)

#fit the adaptive kernel 
#find adaptive kernel using gaussian function
abw <- bw.gwr(price~room +living_area + house_age,
             approach = "AIC", #specified by CV for cross-validation approach or by AIC corrected (AICc), we used AIC 
             adaptive = TRUE,
             kernel="gaussian", #this can be different function e.g., bisquare,exponential, depend on the prior understanding or choice of the modeler
             data=greendata_sp) #give the sp data created earlier
```

```{r}
#fitting the model with gwr.basic function
a.gwr <- gwr.basic(price~room +living_area + house_age, #the equation
             adaptive = TRUE,
             kernel="gaussian", #indicate the Kernel again
             bw = 19, #give the optimal bandwidth we found in the last stage
             data=greendata_sp) 

#print the model result
a.gwr
```

```{r}
EUDM <- gw.dist(coordinates(greendata_sp))

multiGWR_test <- gwr.multiscale(price~room +living_area + house_age, 
                        data = greendata_sp,
                        max.iterations = 1,
                        adaptive = T,  #usually large number to make sure each variable converage to best bandwidth
                        criterion="CVR", #criterion for determining the convergence of the back-fitting procedure
                        kernel = "gaussian", #kernel can also be gaussian, exponential
                        bws0 =c(93,48,46,70),
                        bw.seled = c(T,T,T,T), dMats=list(EUDM,EUDM,EUDM)) 
```
```{r}
gwr.predict(multiGWR_test, data = )
```


```{r}
multiGWR
```

```{r}
#mgwr_sf = st_as_sf(multiGWR$SDF)
#mgwr_sf <- st_read("test_sample(100p)_predictions")
mgwr_sf <- st_read("data/test/test_mgwr.gpkg")

```

```{r}
mgwrM1 <- mapview::mapview(mgwr_sf, zcol = "room", col.regions= brewer.pal(11, "PuOr"), map.type = "CartoDB.Positron")
mgwrM2 <- mapview::mapview(mgwr_sf, zcol = "living_area", col.regions= brewer.pal(11, "PuOr"), map.type = "CartoDB.Positron")
mgwrM3 <- mapview::mapview(mgwr_sf, zcol = "house_age", col.regions= brewer.pal(11, "PuOr"), map.type = "CartoDB.Positron")
mgwrM4 <- mapview::mapview(mgwr_sf, zcol = "residual", col.regions= brewer.pal(11, "PuOr"), map.type = "CartoDB.Positron")
```

```{r}
sync(mgwrM1, mgwrM2, mgwrM3,mgwrM4)
```

